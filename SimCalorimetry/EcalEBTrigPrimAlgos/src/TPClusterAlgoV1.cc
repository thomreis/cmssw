///
/// \class ecalPh2::TPClusterAlgoV1
///
/// \author: Thomas Reis
/// 
/// Version: V1
/// Implements the TP clustering algorithm and calculates the swiss cross
/// spike flag. Clusters are either added if they pass the cluster threshold
/// or if the seed crystal was found to be a spike by the swiss cross method.
///

#include <cmath>
#include <iostream>

#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "CondFormats/DataRecord/interface/EcalBcpPayloadParamsRcd.h"
#include "SimCalorimetry/EcalEBTrigPrimAlgos/interface/EcalBcpPayloadParamsHelper.h"
#include "SimCalorimetry/EcalEBTrigPrimAlgos/interface/TPClusterAlgoV1.h"

ecalPh2::TPClusterAlgoV1::TPClusterAlgoV1(const std::shared_ptr<ecalPh2::EcalBcpPayloadParamsHelper> ecalBcpPayloadParamsHelper) : TPClusterAlgo(ecalBcpPayloadParamsHelper), iEtaDiffMax_(1), iPhiDiffMax_(1), tpClusterThreshold_(1), swissCrossSpikeThreshold_(0.95)
{
  // hard coded cluster size and threshold for the moment
  // TODO: get parameters from configuration

  nTPInCluster_ = (2 * iEtaDiffMax_ + 1) * (2 * iPhiDiffMax_ + 1);
}

void ecalPh2::TPClusterAlgoV1::processEvent(const EcalEBTrigPrimDigiCollection &ebTPs, std::vector<EcalEBTriggerPrimitiveCluster> &ebTPClusters)
{
  std::cout << "Processing TPClusterAlgoV1" << std::endl;
  std::cout << "This TP collection has size: " << ebTPs.size() << std::endl;

  for (size_t i = 0; i < ebTPs.size(); ++i) {
    bool goodSeed = true; // start with the assumption that this is a good seed
    const auto ebTP = ebTPs[i];
    auto ebTPId = ebTP.id();
    //std::cout << "TP for clustering " << i << ": rawId=" << ebTPId.rawId() << ", ieta=" << ebTPId.ieta() << ", iphi=" << ebTPId.iphi() << std::endl;

    // get the algo parameters for this crystal
    const auto peakIdx = ecalBcpPayloadParamsHelper_->sampleOfInterest(ebTPId);
    const auto seedEt = ebTP[peakIdx].encodedEt();
    if (seedEt == 0) {
      continue;
    }

    int nTPAdded = 1;
    int nSwissCrossAdded = 0;
    int sum = seedEt;
    int swissCrossSum = 0;

    // loop over TPs to find adjacent ones
    for (size_t j = 0; j < ebTPs.size(); ++j) {
      if (ebTPId == ebTPs[j].id()) {
        continue;
      }

      const auto distEta = EBDetId::distanceEta(ebTPs[j].id(), ebTPId);
      const auto distPhi = EBDetId::distancePhi(ebTPs[j].id(), ebTPId);
      const auto encodedEt = ebTPs[j][peakIdx].encodedEt();

      // calculate cluster ET sum
      if (distEta <= iEtaDiffMax_ and distPhi <= iPhiDiffMax_) {
        //std::cout << "seed et: " << seedEt << ", seed ieta: " << ebTPId.ieta() << ", seed iphi: " << ebTPId.iphi() << ", et: " << encodedEt << ", distEta: " << distEta << ", distPhi: " << distPhi << ", spike: " << ebTPs[j][peakIdx].l1aSpike() << ", goodSeed: " << goodSeed << std::endl;
        if (goodSeed and ebTPs[j][peakIdx].l1aSpike() == 0) {
          // If a crystal with a higher ET than the seed crystal is found in the
          // cluster area no cluster is made around the seed crystal.
          // A cluster may be made around the higher crystal in a later
          // iteration of the outer for loop. The current seed could still be
          // declared a spike based on the swiss cross method.
          if (seedEt < encodedEt) {
            goodSeed = false;
            sum = -1; // prevent the cluster from being generated by making it fail the threshold
          } else {
            sum += encodedEt;
          }
        }
        ++nTPAdded;
      }

      // calculate swiss cross sum
      if (std::abs(distEta) + std::abs(distPhi) == 1) {
        if (ebTPs[j][peakIdx].l1aSpike() == 0) {
          swissCrossSum += encodedEt;
        }
        ++nSwissCrossAdded;
      }

      // break if all desired crystals were already considered
      if (nSwissCrossAdded == 4) {
        if (nTPAdded >= nTPInCluster_ or not goodSeed) {
          break;
        }
      }
    }

    // swiss cross spike estimation 1 - E_4/E_seed > threshold
    const float swissCross = 1 - static_cast<float>(swissCrossSum) / static_cast<float>(seedEt);
    const bool spike = swissCross > swissCrossSpikeThreshold_;

    // add a cluster object if the cluster passes the threshold or if the seed is a spike
    if (sum >= tpClusterThreshold_ or spike) {
      const auto time = ebTP[peakIdx].time();
      const auto ieta = ebTPId.ieta();
      const auto iphi = ebTPId.iphi();

      std::cout << "Adding TP cluster et=" << sum << ", ieta=" << ieta << ", iphi=" << iphi << ", number of crystals=" << nTPAdded << ", spike=" << spike << ", swiss cross=" << swissCross << std::endl;
      ebTPClusters.emplace_back(EcalEBTriggerPrimitiveCluster(sum, time, ieta, iphi, nTPAdded, spike));
    }
  }
}

